/*
// Copyright (c) 2016 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/

package main

import "testing"

const (
	commentString   = "# Here's a comment\n"
	cloudInitString = `#cloud-config
package_upgrade: true
package_upgrade: false
runcmd:
  - [ ls, -lh, / ]
`
	cloudInitString2 = `groups:
  - cloud-init: [ciao, openstack]
`
	startString = `start:
  requested_resources:
     - type: vcpus
       value: 2
     - type: mem_mb
       value: 256
  instance_uuid: 67d86208-b46c-4465-9018-fe14087d415f
  image_uuid: b286cd45-7d0c-4525-a140-4db6c95e41fa
`
	directivesString = `%TAG ! tag:example.com,2000:app/
%YAML 1.2
---
`
	endString = `...
`
	metaData = `{
    "hostname": "test.novalocal",
    "keys": {
        "data": "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQDBqUfVvCSez0/Wfpd8dLLgZXV9GtXQ7hnMN+Z0OWQUyebVEHey1CXuin0uY1cAJMhUq8j98SiW+cU0sU4J3x5l2+xi1bodDm1BtFWVeLIOQINpfV1n8fKjHB+ynPpe1F6tMDvrFGUlJs44t30BrujMXBe8Rq44cCk6wqyjATA3rQ== Generated by Nova\n"
    },
    "uuid": "83679162-1378-4288-a2d4-70e13ec132aa"
}
`
)

const (
	testStartOnlyString                 = startString
	testStartOnlyLeadingNLString        = "\n" + startString
	testStartOnlySeparatorString        = "---\n" + startString
	testStartOnlySeparatorCommentString = "---\n" + commentString + startString
	testStartOnlyBadSeparatorString     = "---\nwibble:\n" + startString
	testStartOnlyDirectivesString       = directivesString + startString
	testStartFirstString                = directivesString + startString + "...\n" + cloudInitString
	testMetaFirstString                 = cloudInitString + testStartOnlyDirectivesString
	testCloudFirstNoSepString           = cloudInitString + startString
	testMiddleString                    = cloudInitString + testStartOnlyString + cloudInitString2
	testBlankString                     = ""
	testNoStartString                   = endString + endString + endString
	testThreeDocsString                 = cloudInitString + "...\n" + startString + "...\n" + metaData
	testThreeDocsEndString              = "---\n" + cloudInitString + "...\n---\n" + startString + "...\n---\n" + metaData + "...\n"
	testThreeDocsSuperFirstString       = startString + "...\n" + cloudInitString + "...\n" + metaData
	testThreeDocsSuperLastString        = cloudInitString + "...\n" + metaData + "---\n" + startString
	testThreeDocsDirectivesString       = directivesString + cloudInitString + "...\n" + testStartOnlyDirectivesString + "...\n" + metaData
	testStartFourthString               = "...\n" + "...\n" + "...\n" + startString
	testTwoDocsNoSuperString            = cloudInitString + "...\n" + metaData
	testThreeAllStartString             = directivesString + cloudInitString + "...\n" + testStartOnlyDirectivesString + "...\n---\n" + metaData
	testThreeEmptyString                = directivesString + "...\n---\n...\n---\n...\n"
	testThreeEmptyNoStartString         = "...\n...\n...\n"
	testThreeEmptyNoEndString           = "---\n---\n---\n"
	testEmptyString                     = ""
)

// Test YAML parsing code
//
// Launcher needs to parse the YAML it receives in the START command to
// extract the meta_json.js file and the start section, which must
// not be passed to the VM instance.  This test case tests launcher's
// parsing code on a variety of well and badly formed payloads.
//
// Test should pass okay.
func TestSplitYaml(t *testing.T) {
	var start, cn, md []byte

	tests := []struct{ data, s, c, m, n string }{
		{testStartOnlyString, testStartOnlyString, "", "", "testStartOnlyString"},
		{testStartOnlyLeadingNLString, testStartOnlyString, "\n", "", "testStartOnlyLeadingNLString"},
		{testStartOnlySeparatorString, testStartOnlyString, "", "", "testStartOnlySeparatorString"},
		{testStartOnlySeparatorCommentString, testStartOnlyString, commentString, "", "testStartOnlySeparatorCommentString"},
		{testStartOnlyBadSeparatorString, testStartOnlyString, "wibble:\n", "", "testStartOnlyBadSeparatorString"},
		{testStartOnlyDirectivesString, testStartOnlyString, "", "", "testStartOnlyDirectivesString"},
		{testStartFirstString, testStartOnlyString, "", cloudInitString, "testStartFirstString"},
		{testMetaFirstString, testStartOnlyString, "", cloudInitString, "testCloudFirstString"},
		{testCloudFirstNoSepString, testStartOnlyString, cloudInitString, "", "testCloudFirstNoSepString"},
		{testMiddleString, testStartOnlyString, cloudInitString + cloudInitString2, "", "testMiddleString"},
		{testBlankString, "", "", "", "testBlankString"},
		{testNoStartString, "", "", "", "testNoStartString"},
		{testThreeDocsString, startString, cloudInitString, metaData, "testThreeDocs"},
		{testThreeDocsEndString, startString, cloudInitString, metaData, "testThreeDocsEnd"},
		{testThreeDocsSuperFirstString, startString, cloudInitString, metaData, "testThreeDocsSuperFirst"},
		{testThreeDocsSuperLastString, startString, cloudInitString, metaData, "testThreeDocsSuperLast"},
		{testThreeDocsDirectivesString, testStartOnlyString, cloudInitString, metaData, "testThreeDocsDirectives"},
		{testStartFourthString, "", "", "", "testStartFourth"},
		{testTwoDocsNoSuperString, "", cloudInitString, metaData, "testTwoDocsNoSuper"},
		{testThreeAllStartString, testStartOnlyString, cloudInitString, metaData, "testThreeAllStart"},
		{testThreeEmptyString, "", "", "", "testThreeEmpty"},
		{testThreeEmptyNoStartString, "", "", "", "testThreeEmptyNoStart"},
		{testThreeEmptyNoEndString, "", "", "", "testThreeEmptyNoEnd"},
		{testEmptyString, "", "", "", "testEmpty"},
	}

	for _, s := range tests {
		start, cn, md = splitYaml([]byte(s.data))
		if string(start) != s.s || string(cn) != s.c || string(md) != s.m {
			t.Fatalf("%s FAILED", s.n)
		}
	}

}
